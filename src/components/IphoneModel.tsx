/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: polyman (https://sketchfab.com/Polyman_3D)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/apple-iphone-15-pro-max-black-df17520841214c1792fb8a44c6783ee7
Title: Dhyan Model
*/

import * as Three from "three";
import { useGLTF, useTexture } from "@react-three/drei";
import { useEffect, useRef, useState } from "react";
import { useThree } from "@react-three/fiber";

function IphoneModel(props: any) {
  const { nodes, materials } = useGLTF("https://firebasestorage.googleapis.com/v0/b/dhyanapp-90de4.appspot.com/o/Website_New%2FHeroSection%2Fscene.glb?alt=media&token=0f1cedc9-e665-44ee-8aed-6e4c414d8598") as { nodes: any; materials: Record<string, any> };
  const { gl } = useThree();
  const textureRef = useRef<Three.Texture | null>(null);
  // @ts-ignore
  const [isLoading, setIsLoading] = useState(true);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [textureError, setTextureError] = useState(false);

  // Use preloaded textures if available, otherwise fallback to useTexture
  const preloadedTextures = props.item.preloadedTextures;
  const currentTextureIndex = props.item.currentTextureIndex || 0;
  
  // Get the current texture from preloaded array or fallback to useTexture
  const currentTexture = preloadedTextures && preloadedTextures[currentTextureIndex] 
    ? preloadedTextures[currentTextureIndex] 
    : useTexture(props.item.img) as Three.Texture;

  // Create a fallback texture for when SVG fails to load
  const fallbackTexture = useTexture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==") as Three.Texture;

  // Track if onModelLoaded has been called
  const onModelLoadedCalled = useRef(false);

  useEffect(() => {
    // Configure texture for better quality
    if (currentTexture) {
      currentTexture.generateMipmaps = true;
      currentTexture.minFilter = Three.LinearMipmapLinearFilter;
      currentTexture.magFilter = Three.LinearFilter;
      currentTexture.anisotropy = gl.capabilities.getMaxAnisotropy();
      currentTexture.wrapS = Three.ClampToEdgeWrapping;
      currentTexture.wrapT = Three.ClampToEdgeWrapping;
      currentTexture.needsUpdate = true;
      textureRef.current = currentTexture;
      setIsLoading(false);
      setIsInitialLoad(false);
      if (props.onModelLoaded && !onModelLoadedCalled.current) {
        onModelLoadedCalled.current = true;
        props.onModelLoaded();
      }
    }
  }, [currentTexture, gl]);

  // Configure fallback texture
  useEffect(() => {
    if (fallbackTexture) {
      fallbackTexture.generateMipmaps = true;
      fallbackTexture.minFilter = Three.LinearMipmapLinearFilter;
      fallbackTexture.magFilter = Three.LinearFilter;
      fallbackTexture.needsUpdate = true;
    }
  }, [fallbackTexture]);

  // Handle texture loading errors
  useEffect(() => {
    if (props.item.img) {
      const img = new Image();
      img.crossOrigin = "anonymous"; // Add CORS support
      img.onload = () => {
        setTextureError(false);
      };
      img.onerror = () => {
        setTextureError(true);
      };
      img.src = props.item.img;
    }
  }, [props.item.img]);

  useEffect(() => {
    Object.entries(materials).map((material) => {
      if (
        material[0] !== "zFdeDaGNRwzccye" &&
        material[0] !== "ujsvqBWRMnqdwPx" &&
        material[0] !== "hUlRcbieVuIiOXG" &&
        material[0] !== "jlzuBkUzuJqgiAK" &&
        material[0] !== "xNrofRCqOXXHVZt"
      ) {
        material[1].color = new Three.Color(props.item.color);
      }
      material[1].needsUpdate = true;
    });
  }, [materials, props.item]);

  // Set loading state when texture changes (but not on initial load)
  useEffect(() => {
    if (!isInitialLoad) {
      setIsLoading(true);
    }
  }, [props.item.img, isInitialLoad]);

  // Defensive: do not render if no valid image and no preloaded textures
  if (!props.item || (!props.item.preloadedTextures || props.item.preloadedTextures.length === 0) && (!props.item.img || typeof props.item.img !== 'string' || props.item.img.trim().length === 0)) {
    return null;
  }

  return (
    // @ts-expect-error: TypeScript doesn't recognize group
    <group {...props} dispose={null} rotation={[0, Math.PI, 0]}>
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.ttmRoLdJipiIOmf.geometry}
        material={materials.hUlRcbieVuIiOXG}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.DjsDkGiopeiEJZK.geometry}
        material={materials.PaletteMaterial001}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.buRWvyqhBBgcJFo.geometry}
        material={materials.PaletteMaterial002}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.MrMmlCAsAxJpYqQ_0.geometry}
        material={materials.dxCVrUCvYhjVxqy}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wqbHSzWaUxBCwxY_0.geometry}
        material={materials.MHFGNLrDQbTNima}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.QvGDcbDApaGssma.geometry}
        material={materials.kUhjpatHUvkBwfM}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.vFwJFNASGvEHWhs.geometry}
        material={materials.RJoymvEsaIItifI}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.evAxFwhaQUwXuua.geometry}
        material={materials.KSIxMqttXxxmOYl}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.USxQiqZgxHbRvqB.geometry}
        material={materials.mcPrzcBUcdqUybC}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.TvgBVmqNmSrFVfW.geometry}
        material={materials.pIhYLPqiSQOZTjn}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.GuYJryuYunhpphO.geometry}
        material={materials.eShKpuMNVJTRrgg}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.pvdHknDTGDzVpwc.geometry}
        material={materials.xdyiJLYTYRfJffH}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CfghdUoyzvwzIum.geometry}
        material={materials.jpGaQNgTtEGkTfo}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.DjdhycfQYjKMDyn.geometry}
        material={materials.ujsvqBWRMnqdwPx}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.usFLmqcyrnltBUr.geometry}
        material={materials.sxNzrmuTqVeaXdg}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.xXDHkMplTIDAXLN.geometry}
        material={materials.pIJKfZsazmcpEiU}
        scale={0.01}
      > 
        {/* @ts-expect-error: TypeScript doesn't recognize meshStandardMaterial */}
        <meshStandardMaterial 
          roughness={0.05} 
          metalness={0.1}
          map={!textureError ? currentTexture : fallbackTexture}
          transparent={true}
          opacity={1}
          alphaTest={0.01}
          side={Three.DoubleSide}
          emissive={new Three.Color(0xffffff)}
          emissiveIntensity={0.3}
          emissiveMap={!textureError ? currentTexture : fallbackTexture}
          toneMapped={false}
        />
        {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      </mesh>
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.vELORlCJixqPHsZ.geometry}
        material={materials.zFdeDaGNRwzccye}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.EbQGKrWAqhBHiMv.geometry}
        material={materials.TBLSREBUyLMVtJa}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.EddVrWkqZTlvmci.geometry}
        material={materials.xNrofRCqOXXHVZt}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.KSWlaxBcnPDpFCs.geometry}
        material={materials.yQQySPTfbEJufve}
        scale={0.01}
      />
            {/* @ts-expect-error: TypeScript doesn't recognize mesh */}

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.TakBsdEjEytCAMK.geometry}
        material={materials.PaletteMaterial003}
        scale={0.01}
      />
            {/* @ts-expect-error: TypeScript doesn't recognize mesh */}

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.IykfmVvLplTsTEW.geometry}
        material={materials.PaletteMaterial004}
        scale={0.01}
      />
            {/* @ts-expect-error: TypeScript doesn't recognize mesh */}

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.wLfSXtbwRlBrwof.geometry}
        material={materials.oZRkkORNzkufnGD}
        scale={0.01}
      />
            {/* @ts-expect-error: TypeScript doesn't recognize mesh */}

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.WJwwVjsahIXbJpU.geometry}
        material={materials.yhcAXNGcJWCqtIS}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.YfrJNXgMvGOAfzz.geometry}
        material={materials.bCgzXjHOanGdTFV}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.DCLCbjzqejuvsqH.geometry}
        material={materials.vhaEJjZoqGtyLdo}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CdalkzDVnwgdEhS.geometry}
        material={materials.jlzuBkUzuJqgiAK}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.NtjcIgolNGgYlCg.geometry}
        material={materials.PpwUTnTFZJXxCoE}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.pXBNoLiaMwsDHRF.geometry}
        material={materials.yiDkEwDSyEhavuP}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.IkoiNqATMVoZFKD.geometry}
        material={materials.hiVunnLeAHkwGEo}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.rqgRAGHOwnuBypi.geometry}
        material={materials.HGhEhpqSBZRnjHC}
        scale={0.01}
      />
      {/* @ts-expect-error: TypeScript doesn't recognize mesh */}
    </group>
  );
}

export default IphoneModel;

useGLTF.preload("/models/scene.glb");